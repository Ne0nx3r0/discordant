import ItemEquippable from './ItemEquippable';
import Weapon from './Weapon';
import BareHands from './weapons/BareHands';

export interface EquipmentBag{
    amulet?: ItemEquippable;//element resistance, item find, critical hits
    armor?: ItemEquippable;//physical resistance
    bracer?: ItemEquippable;//element resistance, item find, critical hits
    hat?: ItemEquippable;// ?
    offhand?: Weapon;
    ring?: ItemEquippable;//element resistance, item find, critical hits
    weapon?: Weapon;
}

export type EquipmentSlot = 
    'amulet' |
    'armor' |
    'bracer' |
    'hat' |
    'offhand' |
    'ring' |
    'weapon'
;

interface ForEachItemFunc{
    (item:ItemEquippable,slot:EquipmentSlot): void
}

export default class CreatureEquipment{
    _items:EquipmentBag;

    constructor(equipmentBag:EquipmentBag){
        this._items = equipmentBag;
    }

    //Returns the item that was in that slot, or undefined
    equip(item:ItemEquippable,slot:EquipmentSlot):ItemEquippable{
        //This shouldn't ever happen (tm)
        //But if a non-weapon was equipped to the weapon slot a LOT more errors would
        //Be generated by battles or other functions that expect those itemequippables to be weapons
        if(item instanceof Weapon && slot != 'weapon' && slot != 'offhand'){
            throw "Cannot equip a weapon to slot "+slot;
        }

        //Curiously, you could equip clothing to weapon slots without side effects
        //But it would lead to the player looking ridiculous in battle
        
        const removedItem = this._items[slot];

        this._items[slot] = item;

        return removedItem;
    }

    //Returns the item that was in that slot, or undefined
    unequip(slot:EquipmentSlot){
        const removedItem = this._items[slot];

        delete this._items[slot];

        return removedItem;
    }

    forEach(callback:ForEachItemFunc){
        Object.keys(this._items).forEach((slot:EquipmentSlot)=>{
            callback(this._items[slot] as ItemEquippable,slot);
        });
    }

    toDatabase():EquipmentBag{
        const toDb = {};

        Object.keys(this._items).forEach((slot:EquipmentSlot)=>{
            toDb[slot] = {
                id: this._items[slot].id
            };
        });

        return toDb;
    }

    get all():EquipmentBag{
        return this._items;
    }

    get hat():ItemEquippable{
        return this._items.hat;
    }

    get armor():ItemEquippable{
        return this._items.armor;
    }

    get ring():ItemEquippable{
        return this._items.ring;
    }

    get amulet():ItemEquippable{
        return this._items.amulet;
    }

    get bracer():ItemEquippable{
        return this._items.bracer;
    }

    get weapon():ItemEquippable{
        return this._items.weapon;
    }

    get offhand():ItemEquippable{
        return this._items.offhand;
    }


    get primaryweapon():Weapon{
        return this._items.weapon || BareHands;
    }

    get offhandweapon():Weapon{
        return this._items.offhand || BareHands;
    }
}