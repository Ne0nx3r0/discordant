import ItemEquippable from './ItemEquippable';
import Weapon from './Weapon';
import BareHands from './weapons/BareHands';

export interface EquipmentBag{
    amulet?: ItemEquippable;//element resistance, item find, critical hits
    armor?: ItemEquippable;//physical resistance
    earring?: ItemEquippable;//element resistance, item find, critical hits
    hat?: ItemEquippable;// ?
    offhandweapon?: Weapon;
    primaryweapon?: Weapon;
    ring?: ItemEquippable;//element resistance, item find, critical hits
}

export type EquipmentSlot = 
    'amulet' |
    'armor' |
    'earring' |
    'hat' |
    'offhandweapon' |//note these are all lower case so you have the option to use toLowerCase
    'primaryweapon' |//they should be upper, but I hate looking at THINGSINFUCKINGUPPERCASE
    'ring'
;

interface ForEachItemFunc{
    (item:ItemEquippable,slot:EquipmentSlot): void
}

export default class CreatureEquipment{
    _items:EquipmentBag;

    constructor(equipmentBag:EquipmentBag){
        this._items = equipmentBag;
    }

    //Returns the item that was in that slot, or undefined
    equip(item:ItemEquippable,slot:EquipmentSlot):ItemEquippable{
        //This shouldn't ever happen (tm)
        //But if a non-weapon was equipped to the weapon slot a LOT more errors would
        //Be generated by battles or other functions that expect those itemequippables to be weapons
        if(item instanceof Weapon && slot != 'primaryweapon' && slot != 'offhandweapon'){
            throw "Cannot equip a weapon to slot "+slot;
        }

        //Curiously, you could equip clothing to weapon slots without side effects
        //But it would lead to the player looking ridiculous in battle
        
        const removedItem = this._items[slot];

        this._items[slot] = item;

        return removedItem;
    }

    //Returns the item that was in that slot, or undefined
    unequip(slot:EquipmentSlot){
        const removedItem = this._items[slot];

        delete this._items[slot];

        return removedItem;
    }

    forEach(callback:ForEachItemFunc){
        Object.keys(this._items).forEach((slot:EquipmentSlot)=>{
            callback(this._items[slot] as ItemEquippable,slot);
        });
    }

    toDatabase():EquipmentBag{
        const toDb = {};

        Object.keys(this._items).forEach((slot:EquipmentSlot)=>{
            toDb[slot] = {
                id: this._items[slot].id
            };
        });

        return toDb;
    }

    get all():EquipmentBag{
        return this._items;
    }

    get hat():ItemEquippable{
        return this._items.hat;
    }

    get armor():ItemEquippable{
        return this._items.hat;
    }

    get amulet():ItemEquippable{
        return this._items.hat;
    }

    get ring():ItemEquippable{
        return this._items.hat;
    }

    get earring():ItemEquippable{
        return this._items.hat;
    }

    get primaryweapon():Weapon{
        return this._items.primaryweapon || BareHands;
    }

    get offhandweapon():Weapon{
        return this._items.offhandweapon || BareHands;
    }
}